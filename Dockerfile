# Этап 1: Сборка приложения
FROM golang:1.23-alpine AS builder

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Копируем файлы управления зависимостями
COPY go.mod go.sum ./

# Загружаем зависимости Go. Это кэшируется, если go.mod/go.sum не менялись
RUN go mod download

# Копируем весь исходный код проекта
COPY . .

# Собираем приложение
# -o /app/server - имя выходного исполняемого файла
# CGO_ENABLED=0 - отключаем CGO для статической сборки
# -ldflags="-w -s" - уменьшает размер бинарника (убирает отладочную информацию)
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o /app/server ./cmd/app/main.go

# Этап 2: Создание минимального финального образа
FROM alpine:latest

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем только собранный бинарник из этапа сборки
COPY --from=builder /app/server /app/server

# Копируем скрипт инициализации БД (если нужно его запускать из приложения, обычно не нужно)
# COPY init.sql /docker-entrypoint-initdb.d/ # Это больше для образа Postgres, не сюда

# Открываем порт, который слушает наше приложение (указан в main.go)
EXPOSE 8080

# Команда для запуска приложения при старте контейнера
CMD ["/app/server"]